:::warning
- [ ] 待處理的問題: 在sub到訊息發送若發生錯誤，log記錄? 該怎麼處理(retry, retry-limit)? 該通知誰?
- [ ] 確認是bug的地方TPI有沒有修改 
:::

[toc]

- [x] 7/24開會，TPI說已針對寄送訊息的程式做檢查與修改，等新版程式再確認exception有沒有處理
Ans: 確認分支 SIT/0726-0.5.13 根本自暴自棄的錯誤就往外丟... 
![](https://hackmd.io/_uploads/SyAd791jn.png)

- 具有以下服務: SMS, EMAIL, OTP, Notification
- 寄送模式: 同步, 非同步

# 同步模式
:question: 需確認 呼叫寄送的第三方server過程有發生錯誤，是如何處理與回覆? 並是否有記錄error log? 在GCP查找時可以使用什麼關鍵字?
```java=
// SMS
service接下最大 的Exception 再
throw new InternalServerErrorException(
    "MSGCR-B-SSENDSMSO001-3", "twilio-handshake-error", e);
後續由 GlobalExceptionHandler - @ExceptionHandler(value = InternalServerErrorException.class) 處理

// EMAIL
SendgridManager接下最大的Exception 再
log.error("Failed to send email: {}", e.getMessage());
throw Problem.builder()
                .withStatus(Status.INTERNAL_SERVER_ERROR)
                .withTitle(Status.INTERNAL_SERVER_ERROR.getReasonPhrase())
                .withDetail("Failed to send email.")
                .with("email", receiver)
                .build();
後續由 GlobalExceptionHandler - @ExceptionHandler(value = Exception.class) 處理

// OTP
依照 otp code 要使用 sms 還是 email 發送最對應的處理

// Notification
service接下最大 的Exception 再
throw new InternalServerErrorException(
    "MSGCR-B-SENDNTFYO001-3", "firebase-handshake-error", e);
後續由 GlobalExceptionHandler - @ExceptionHandler(value = InternalServerErrorException.class) 處理
    // 成功推播後會再 notify pub/sub that message sent success
PubSunManager接下 InterruptedException + Exception 再統一丟出
throw new InternalServerErrorException(ie.getMessage(), ie);
後續由 GlobalExceptionHandler - @ExceptionHandler(value = InternalServerErrorException.class) 處理

// GlobalExceptionHandler 的處理方式
1. log.error(getErrorMsg(ex), ex);
2. 紀錄一筆 ExecutionRecord 到db
3. 皆使用(HttpStatus.INTERNAL_SERVER_ERROR + 上面描述的API method & 錯誤原因) 回覆
```

## SMS
:::success
1. 組合資料
2. 呼叫 TwilioManager.sendSms()，==在呼叫方的ServiceImpl去處理Exception==，拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error 
![](https://hackmd.io/_uploads/SJrgSSysn.png)
3. 若發送成功，新增一筆 SmsMsgEntity  (with sendTimeStamp)
:::

## EMAIL
:::success
1. 組合資料
2. 呼叫 SendgridManager.sendMail()，==在Manager去處理Exception==，寫入GCP log.error + 拋出 Problem-Status.INTERNAL_SERVER_ERROR
3. 若發送成功，新增一筆 MailMsgEntity (with sendTimeStamp)
:::

## OTP
:::success
1. 根據通知方式組合資料 (1: SMS+MAIL, 2: SMS, 3: MAIL)
2. 承上去呼叫對應的Manager
3. 若發送成功，新增一筆 OtpEntity (with sendTimeStamp)
:::

## Notification
:::success
1. 組合資料
2. 呼叫 FirebaseManager.pushNotification()，==在呼叫方的ServiceImpl去處理Exception==，拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error 
3. 若發送成功，呼叫 PubsubManager.publishNotificationSuccess()
    - 在manager處理 Exception -> 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error
    - 在manager處理 InterruptedException -> Thread.currentThread().interrupt(); + 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error 
4. 新增一筆 NotificationMsgEntity (with sendTimeStamp)
:::

# 非同步模式
:question: 需確認 publish過程有發生錯誤，是如何處理與回覆? 並是否有記錄error log? 在GCP查找時可以使用什麼關鍵字?
```java=
// SMS + EMAIL + Notification
// 因為都是將訊息先發送到pub/sub 所以都是由 manager 處理
PubSubManager接下 InterruptedException + Exception 再統一丟出
throw new InternalServerErrorException(ie.getMessage(), ie);
後續由 GlobalExceptionHandler - @ExceptionHandler(value = InternalServerErrorException.class) 處理

// GlobalExceptionHandler 的處理方式
1. log.error(getErrorMsg(ex), ex);
2. 紀錄一筆 ExecutionRecord 到db
3. 使用(HttpStatus.INTERNAL_SERVER_ERROR + 上面描述的API method & 錯誤原因) 回覆
```

## SMS
:::success
1. 新增一筆 SmsMsgEntity
2. 組合資料
3. 呼叫 PubsubManager.publishAsyncSms()
    - 在manager處理 Exception -> 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error
    - 在manager處理 InterruptedException -> Thread.currentThread().interrupt(); + 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error 
4. 接著就是subscription的處理
:::

## EMAIL
:::success
1. 新增一筆 MailMsgEntity
2. 組合資料
3. 呼叫 PubsubManager.publishAsyncMail()
    - 在manager處理 Exception -> 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error
    - 在manager處理 InterruptedException -> Thread.currentThread().interrupt(); + 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error
4. 接著就是subscription的處理
:::

## Notification
:::success
1. 新增一筆 NotificationEntity
2. 組合資料
3. 呼叫 PubsubManager.publishAsyncNotification()
    - 在manager處理 Exception -> 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error
    - 在manager處理 InterruptedException -> Thread.currentThread().interrupt(); + 拋出InternalServerErrorException 並透過 GlobalExceptionHandler 寫入GCP log.error
4. 接著就是subscription的處理
:::

# Subscription
:question: 需確認 若訊息沒有成功透過第三方發送，或是過程有發生錯誤，是如何處理與回覆? 會通知誰? 並是否有記錄error log? 在GCP查找時可以使用什麼關鍵字?
```java=
// SMS 
發送過程中 TwilioManager可能的錯誤都沒有處理????
    
// EMAIL
發送過程中 SendgridManager可能的錯誤，會被以最大的Exception接下來，丟出Problem
再由 GlobalExceptionHandler 處理

// Notification
1. 發送過程中 FirebaseManager可能的錯誤都沒有處理????
2. 接著的成功發送通知，會由PubsubManager接下InterruptedException + Exception 
丟出 InternalServerErrorException 再由 GlobalExceptionHandler 處理

// GlobalExceptionHandler 的處理方式
1. log.error(getErrorMsg(ex), ex);
2. 紀錄一筆 ExecutionRecord 到db
3. 使用(HttpStatus.INTERNAL_SERVER_ERROR + 上面描述的API method & 錯誤原因) 回覆
```

:bulb: ack()的動作就是將message queue的資料是放清除吧?
A: 是的，ack()就會清除queue的資料

:bulb: 請問這裡的訂閱模式是由訂閱者主動拉取訊息? 頻率是多久一次? 這些設定是寫在?
A:訂閱者主動去拉topic裡面的資料，頻率是default值，一切都設定在GCP....

:bulb: 請問第一次查找redis的時候會回覆 processed = null ?
A:是的第一次查不到資料，就會進入區塊中進行發送
![](https://hackmd.io/_uploads/rybggUks2.png)

## SMS
:::success
1. 接收資料
2. 透過redis判斷此訊息是否處理過 (by MessageId)
3. 若尚未發送過
    - 則呼叫 TwilioManager.sendSms() :question: 並沒有任何發送錯誤的處理??? ==TPI說這個沒辦法定義情境(就算twilio回覆發送成功也不能真的確定有發送成功)也不知道retry機制要怎樣==
    - 若發送成功，將SmsMsgEntity 更新多個欄位 :question: 為什麼連create都要改? ==等TPI改==
    - 將訊息 ack() ==這個是錯的!!!!!等TPI改==
![](https://hackmd.io/_uploads/HJN_Rrkih.png)
:::

## EMAIL
:::success
1. 接收資料
2. 透過redis判斷此訊息是否處理過 (by MessageId)
3. 若尚未發送過
    - 則呼叫 SendgridManager.sendMail()，由Manager處理Exception拋出Problem.Status.INTERNAL_SERVER_ERROR
    - 若發送成功，將MailMsgEntity 更新 SentTimestamp
4. 不管有沒有發送過都將訊息 ack() :heavy_exclamation_mark: :heavy_exclamation_mark: 
A: 這個才是對的，目前設計避免一直重複發送(可能是因為第三方有問題)，但也會造成其實客戶沒收到... 

![](https://hackmd.io/_uploads/SyUMJU1o3.png)
:::

## Notification
:::success
1. 接收資料
2. 透過redis判斷此訊息是否處理過 (by MessageId)
3. 若尚未發送過
    - 則呼叫 FirebaseManager.pushNotification() :question: 此處沒有任何發生錯誤的處理??
    - 再呼叫 PubsubManager.publishNotificationSuccess()，由Manager處理了 InterruptedException + Exception類型
    - 若以上都成功，將NotificationMsgEntity 更新 SentTimestamp + UpdatedTimestamp..
    - 將訊息 ack() ==這個是錯的!!!!!等TPI改==

![](https://hackmd.io/_uploads/S1Ve-Iyi2.png)
:::

# PubSubHandlerManager
:::info
透過 generatePubSubConsumer 統一處理: 
1.新增 pubsubLog 到db (欄位: MessageId + Payload + PublishTimestamp)
2.根據 messageId 新增error log => pub/sub error: messageId:{}, error message: {}
```java=
public <T> Consumer<ConvertedBasicAcknowledgeablePubsubMessage<T>> generatePubSubConsumer(
            Consumer<ConvertedBasicAcknowledgeablePubsubMessage<T>> messageConsumer,
            Class<T> payloadType) {
        return s -> {
            try {
                log.info(MESSAGE_LOG, s.getPayload());
                createPubsubLog(s.getPubsubMessage());
            
                messageConsumer.accept(s);
            } catch (Exception e) {
                log.error(ERROR_MESSAGE_LOG, s.getPubsubMessage().getMessageId(), e.getMessage(), e);
                // 發生錯誤就一樣訊息清除....
                s.ack();
            }
        };
    }
```
:::